(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{407:function(e,a,r){"use strict";r.r(a);var t=r(25),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"基于-monorepo-管理的前端组件模块化开发库管理模版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于-monorepo-管理的前端组件模块化开发库管理模版"}},[e._v("#")]),e._v(" 基于 monorepo 管理的前端组件模块化开发库管理模版")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("特别")]),e._v(" "),r("p",[r("strong",[e._v("本文从为什么,是什么,怎么做分析 monorepo 包管理方式,文章中有具体的实现方法,附源码.")])])]),e._v(" "),r("h2",{attrs:{id:"why-repo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#why-repo"}},[e._v("#")]),e._v(" Why Repo?")]),e._v(" "),r("p",[e._v("首先看这篇文章之前,问一下自己,你是否进行过 package 开发,如果是,那么你应该知道的  在进行包开发的时候,难以避免的就是要测试包的可用性,或者在开发的时候的调试 demo 很大程度上都是以下两种方式")]),e._v(" "),r("ul",[r("li",[e._v("npm link")]),e._v(" "),r("li",[e._v("在内部 example 直接引用文件")])]),e._v(" "),r("h4",{attrs:{id:"npm-link"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npm-link"}},[e._v("#")]),e._v(" npm link")]),e._v(" "),r("p",[e._v("这种方式使用 npm link 创建软连接的形式, 将包连接到全局的node_modules 中,在 需要用到 package 的地方 npm link package 的方式,在从项目中软连接到项目中的 node_modules 中, 在开发中这种模式,我遇到的两个问题就是")]),e._v(" "),r("ol",[r("li",[e._v("多依赖开发的时候,开发完一个包需要重新 npm link 避免代码还是没改之前的问题.这样就无法创建统一的工作流.")]),e._v(" "),r("li",[e._v("因为软连接在解析的时候,会被解析为绝对路径,也就是你当前的包代码所在的位置, 这样的路径会绕过项目的 eslint 校验,出现eslint 报错无法绕过的问题")])]),e._v(" "),r("h4",{attrs:{id:"example-方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#example-方式"}},[e._v("#")]),e._v(" example 方式")]),e._v(" "),r("p",[e._v("这种方式在内部直接使用源码或者打包出来的代码,绕过了 npm 包管理方式, 使你在发布版本的时候,需要额外的时间来确定是否是安全的配置包.")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("总结")]),e._v(" "),r("p",[e._v("可以看到传统的 单repo 的包管理方式:")]),e._v(" "),r("ol",[r("li",[e._v("无法实现代码的快速 code Sharking")]),e._v(" "),r("li",[e._v("无法实现完整的多依赖包开发工作流")])])]),e._v(" "),r("h2",{attrs:{id:"what-repo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#what-repo"}},[e._v("#")]),e._v(" What Repo ?")]),e._v(" "),r("p",[r("strong",[e._v("Monorepo——大型前端项目的代码管理方式")])]),e._v(" "),r("p",[e._v("Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)，不同于常见的每个模块建一个 repo。")]),e._v(" "),r("p",[e._v("monorepo 最主要的好处是统一的工作流和Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。")]),e._v(" "),r("p",[e._v("目前有不少大型开源项目采用了这种方式，如 Babel，React, Meteor, Ember, Angular,Jest, Umijs, Vue, 还有 create-react-app, react-router 等。几乎我们熟知的仓库，都无一例外的采用了monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages目录中、分多个 package 进行管理。")]),e._v(" "),r("p",[r("em",[r("strong",[e._v("当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。")])])]),e._v(" "),r("p",[r("strong",[e._v("monorepo 项目结构")])]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("├── packages\n|   ├── package1\n|   |   ├── package.json\n|   ├── package2\n|   |   ├── package.json\n├── package.json\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br")])]),r("h2",{attrs:{id:"how-repo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#how-repo"}},[e._v("#")]),e._v(" How Repo?")]),e._v(" "),r("p",[e._v("monorepo 的实现依赖于实现两大问题的技术:")]),e._v(" "),r("p",[r("strong",[e._v("1. 包依赖管理 code Sharking(基于Yarn workspace)")])]),e._v(" "),r("p",[r("strong",[e._v("2. 统一发版,更新时依赖更新(基于 lerna 或者 自实现的发布工作流)")])]),e._v(" "),r("h4",{attrs:{id:"yarn-workspace"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yarn-workspace"}},[e._v("#")]),e._v(" Yarn workspace")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://lernajs.bootcss.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("lerna"),r("OutboundLink")],1),e._v("  也提供了依赖关系管理的能力, 但是需要使用 "),r("a",{attrs:{href:"https://lernajs.bootcss.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("lerna"),r("OutboundLink")],1),e._v("  特定的方式进行依赖安装等操作.这里直接使用 yarn 作为包版本工具.本文不涉及到 "),r("a",{attrs:{href:"https://lernajs.bootcss.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("lerna"),r("OutboundLink")],1),e._v(" 的包版本控制方法.")])])])}),[],!1,null,null,null);a.default=s.exports}}]);