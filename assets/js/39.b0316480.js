(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{425:function(T,_,v){"use strict";v.r(_);var t=v(25),S=Object(t.a)({},(function(){var T=this,_=T.$createElement,v=T._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":T.$parent.slotKey}},[v("p",[v("strong",[T._v("基本概念")]),T._v("\nHTTP（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。")]),T._v(" "),v("p",[T._v("HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。")]),T._v(" "),v("p",[T._v("HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。")]),T._v(" "),v("p",[T._v("HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。")]),T._v(" "),v("p",[v("strong",[T._v("HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：")])]),T._v(" "),v("ol",[v("li",[T._v("TCP 三次同步握手")]),T._v(" "),v("li",[T._v("客户端验证服务器数字证书")]),T._v(" "),v("li",[T._v("DH 算法协商对称加密算法的密钥. hash 算法的密钥")]),T._v(" "),v("li",[T._v("SSL 安全加密隧道协商完成")]),T._v(" "),v("li",[T._v("网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。\n截至 2018 年 6 月，Alexa 排名前 100 万的网站中有 34.6% 使用 HTTPS 作为默认值，互联网 141387 个最受欢迎网站的 43.1% 具有安全实施的 HTTPS，以及 45% 的页面加载（透过Firefox纪录）使用HTTPS。2017 年3 月，中国注册域名总数的 0.11％使用 HTTPS。")])]),T._v(" "),v("p",[T._v("根据 Mozilla 统计，自 2017 年 1 月以来，超过一半的网站流量被加密。")]),T._v(" "),v("p",[v("strong",[T._v("HTTP 与 HTTPS 区别")]),T._v(" "),v("strong",[T._v("HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。")]),T._v("\n使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。\nHTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\nhttp 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。\nHTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。\nTCP 三次握手s\n在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接")]),T._v(" "),v("p",[T._v("第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认\n第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态\n第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手\n简化：")]),T._v(" "),v("h3",{attrs:{id:"https-的工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-的工作原理"}},[T._v("#")]),T._v(" HTTPS 的工作原理")]),T._v(" "),v("p",[T._v("我们都知道 HTTPS 能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用 HTTPS 协议。")]),T._v(" "),v("p",[T._v("1、客户端发起 HTTPS 请求")]),T._v(" "),v("p",[T._v("这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。")]),T._v(" "),v("p",[T._v("2、服务端的配置")]),T._v(" "),v("p",[T._v("采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。")]),T._v(" "),v("p",[T._v("这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。")]),T._v(" "),v("p",[T._v("3、传送证书")]),T._v(" "),v("p",[T._v("这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。")]),T._v(" "),v("p",[T._v("4、客户端解析证书")]),T._v(" "),v("p",[T._v("这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。")]),T._v(" "),v("p",[T._v("如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。")]),T._v(" "),v("p",[T._v("5、传送加密信息")]),T._v(" "),v("p",[T._v("这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。")]),T._v(" "),v("p",[T._v("6、服务端解密信息")]),T._v(" "),v("p",[T._v("服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。")]),T._v(" "),v("p",[T._v("7、传输加密后的信息")]),T._v(" "),v("p",[T._v("这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。")]),T._v(" "),v("p",[T._v("8、客户端解密信息")]),T._v(" "),v("p",[T._v("客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策")])])}),[],!1,null,null,null);_.default=S.exports}}]);